import org.emftext.language.java.modifiers.ModifiersFactory
import org.emftext.language.java.arrays.ArrayInstantiationByValuesTyped
import org.emftext.language.java.references.StringReference
import org.emftext.language.java.expressions.Expression
import tools.vitruv.applications.pcmjava.confidentialitytransformations.confidentiality2annotations.Confidentiality2AnnotationsUtil
import tools.vitruv.applications.pcmjava.confidentialitytransformations.confidentiality2annotations.Confidentiality2AnnotationsContentCreationUtil
import edu.kit.kastel.scbs.confidentiality.data.DataSet
import java.util.Optional
import static extension tools.vitruv.applications.pcmjava.confidentialitytransformations.confidentiality2annotations.Confidentiality2AnnotationsUtil.*

import "http://www.emftext.org/java" as java
import "http://edu.kit.kastel.scbs.confidentiality" as conf

reactions: Confidentiality2Annotations 
in reaction to changes in Confidentiality
execute actions in Java

// ###################################################
// ############### DATA SET REACTIONS ################

reaction CreatedDataSet {
	after element conf::DataSet created and inserted in conf::ConfidentialitySpecification[dataIdentifier]
	call createDataSetAndInitialize(newValue, affectedEObject)
}

routine createDataSetAndInitialize(conf::DataSet createdDataSet, conf::ConfidentialitySpecification confidentialitySpecification) {
	match {
		val dataSetsType = retrieve java::Enumeration corresponding to confidentialitySpecification tagged with "DataSets"
	}
	action {
		val enumConstant = create java::EnumConstant and initialize {
			Confidentiality2AnnotationsUtil.setDataSetEnumConstantContent(enumConstant, createdDataSet)
		}
		update dataSetsType {
			dataSetsType.constants.add(enumConstant)
		}
		add correspondence between createdDataSet and enumConstant
	}
}

reaction ReplacedDataSet {
	after element conf::DataSet replaced at conf::ConfidentialitySpecification[dataIdentifier]
	call replaceDataSet(newValue, oldValue, affectedEObject)
}

routine replaceDataSet(conf::DataSet newDataSet, conf::DataSet oldDataSet, conf::ConfidentialitySpecification confidentialitySpecification) {
	match {
		val dataSetsType = retrieve java::Enumeration corresponding to confidentialitySpecification tagged with "DataSets"
		val enumConstant = retrieve java::EnumConstant corresponding to oldDataSet
	}
	action {
		update enumConstant {
			Confidentiality2AnnotationsUtil.setDataSetEnumConstantContent(enumConstant, newDataSet)
		}
		remove correspondence between oldDataSet and enumConstant
		add correspondence between newDataSet and enumConstant
	}
}

reaction DeletedDataSet {
	after element conf::DataSet removed from conf::ConfidentialitySpecification[dataIdentifier]
	call deleteDataSet(oldValue, affectedEObject)
}

routine deleteDataSet(conf::DataSet deletedDataSet, conf::ConfidentialitySpecification confidentialitySpecification) {
	match {
		val dataSetsType = retrieve java::Enumeration corresponding to confidentialitySpecification tagged with "DataSets"
		val enumConstant = retrieve java::EnumConstant corresponding to deletedDataSet
	}
	action {
		update dataSetsType {
			dataSetsType.constants.remove(enumConstant)
		}
		delete enumConstant
	}
}

// ################## VALUE CHANGES ##################

reaction ChangedDataSetName {
	after attribute replaced at conf::DataSet[name]
	call changeDataSetName(affectedEObject)
}

routine changeDataSetName(conf::DataSet dataSet) {
    match {
        val enumConstant = retrieve java::EnumConstant corresponding to dataSet
    }
    action {
        update enumConstant {
            enumConstant.name = Confidentiality2AnnotationsUtil.createEnumConstantName(dataSet.name);
            Confidentiality2AnnotationsUtil.changeDataSetEnumConstantNameArgument(enumConstant, dataSet);
        }
    }
}

reaction ChangedDataSetId {
	after attribute replaced at conf::DataSet[id]
	call changeDataSetId(affectedEObject)
}

routine changeDataSetId(conf::DataSet dataSet) {
    match {
        val enumConstant = retrieve java::EnumConstant corresponding to dataSet
    }
    action {
        update enumConstant {
            Confidentiality2AnnotationsUtil.changeDataSetEnumConstantIdArgument(enumConstant, dataSet);
        }
    }
}

// ###################################################
// ######## PARAMETER AND DATA PAIRS REACTIONS #######

reaction CreatedParametersAndDataPair {
	after element conf::ParametersAndDataPair created and inserted in conf::ConfidentialitySpecification[parametersAndDataPairs]
	call createParametersAndDataPairAndInitialize(newValue, affectedEObject)
}

routine createParametersAndDataPairAndInitialize(conf::ParametersAndDataPair pair, conf::ConfidentialitySpecification confidentialitySpecification) {
	match {
		val parametersAndDataPairType = retrieve java::Enumeration corresponding to confidentialitySpecification tagged with "ParametersAndDataPairs"
	}
	action {
		val enumConstant = create java::EnumConstant and initialize {
			parametersAndDataPairType.constants.add(enumConstant)
			Confidentiality2AnnotationsUtil.setParameterAndDataPairEnumConstantContent(enumConstant, pair);
		}
		add correspondence between pair and enumConstant
	}
}

reaction ReplacedParametersAndDataPair {
	after element conf::ParametersAndDataPair replaced at conf::ConfidentialitySpecification[parametersAndDataPairs]
	call replaceParametersAndDataPair(newValue, oldValue, affectedEObject)
}

routine replaceParametersAndDataPair(conf::ParametersAndDataPair newParametersAndDataPair, conf::ParametersAndDataPair oldParametersAndDataPair, conf::ConfidentialitySpecification confidentialitySpecification) {
	match {
		val parametersAndDataPairsType = retrieve java::Enumeration corresponding to confidentialitySpecification tagged with "ParametersAndDataPairs"
		val enumConstant = retrieve java::EnumConstant corresponding to oldParametersAndDataPair
	}
	action {
		update enumConstant {
			Confidentiality2AnnotationsUtil.setParameterAndDataPairEnumConstantContent(enumConstant, newParametersAndDataPair)
		}
		remove correspondence between oldParametersAndDataPair and enumConstant
		add correspondence between newParametersAndDataPair and enumConstant
	}
}

reaction DeletedParametersAndDataPair {
	after element conf::ParametersAndDataPair removed from conf::ConfidentialitySpecification[parametersAndDataPairs]
	call deleteParametersAndDataPair(oldValue, affectedEObject)
}

routine deleteParametersAndDataPair(conf::ParametersAndDataPair deletedParametersAndDataPair, conf::ConfidentialitySpecification confidentialitySpecification) {
	match {
		val parametersAndDataPairsType = retrieve java::Enumeration corresponding to confidentialitySpecification tagged with "ParametersAndDataPairs"
		val enumConstant = retrieve java::EnumConstant corresponding to deletedParametersAndDataPair
	}
	action {
		update parametersAndDataPairsType {
			parametersAndDataPairsType.constants.remove(enumConstant)
		}
		delete enumConstant
	}
}

// ################## VALUE CHANGES ##################

reaction ChangedParametersAndDataPairName {
	after attribute replaced at conf::ParametersAndDataPair[name]
	call changeParametersAndDataPairName(affectedEObject)
}

routine changeParametersAndDataPairName(conf::ParametersAndDataPair parametersAndDataPair) {
    match {
        val enumConstant = retrieve java::EnumConstant corresponding to parametersAndDataPair
    }
    action {
        update enumConstant {
            enumConstant.name = Confidentiality2AnnotationsUtil.createEnumConstantName(parametersAndDataPair.name);
        }
    }
}

reaction InsertedParametersAndDataPairDataTarget {
	after element inserted in conf::ParametersAndDataPair[dataTargets]
	call insertParametersAndDataPairDataTarget(affectedEObject, newValue, index)
}

reaction DeletedParametersAndDataPairDataTarget {
	after element removed from conf::ParametersAndDataPair[dataTargets]
	call deleteParametersAndDataPairDataTarget(affectedEObject, oldValue, index)
}

reaction ReplacedParametersAndDataPairDataTarget {
	after element replaced at conf::ParametersAndDataPair[dataTargets]
	call {
		replaceParametersAndDataPairDataTarget(affectedEObject, newValue, oldValue)
	}
}

routine insertParametersAndDataPairDataTarget(conf::ParametersAndDataPair parametersAndDataPair, conf::DataIdentifying dataTarget, Integer position) {
    match {
        val pairEnumConstant = retrieve java::EnumConstant corresponding to parametersAndDataPair
        val dataSetEnumConstant = retrieve java::EnumConstant corresponding to dataTarget
    }
    action {
        update pairEnumConstant {
        		val enumConstantName = Confidentiality2AnnotationsUtil.createEnumConstantName((dataTarget as DataSet).name)
				val newDataSetExpression = Confidentiality2AnnotationsContentCreationUtil.createEnumerationReferenceDotEnumConstant(DATA_SETS_ENUMERATION, enumConstantName)
				val arrayArguments = (pairEnumConstant.arguments.get(PAIR_ARGUMENT_DATA_SETS) as ArrayInstantiationByValuesTyped).arrayInitializer.initialValues
				arrayArguments.add(position, newDataSetExpression)
        }
    }
}

routine deleteParametersAndDataPairDataTarget(conf::ParametersAndDataPair parametersAndDataPair, conf::DataIdentifying dataTarget, Integer position) {
    match {
        val pairEnumConstant = retrieve java::EnumConstant corresponding to parametersAndDataPair
        val dataSetEnumConstant = retrieve java::EnumConstant corresponding to dataTarget
    }
    action {
        update pairEnumConstant {
		 		(pairEnumConstant.arguments.get(PAIR_ARGUMENT_DATA_SETS) as ArrayInstantiationByValuesTyped).arrayInitializer.initialValues.remove(position as int)
        }
    }
}

routine replaceParametersAndDataPairDataTarget(conf::ParametersAndDataPair parametersAndDataPair, conf::DataIdentifying newDataTarget, conf::DataIdentifying oldDataTarget) {
    match {
        val pairEnumConstant = retrieve java::EnumConstant corresponding to parametersAndDataPair
        val dataSetEnumConstant = retrieve java::EnumConstant corresponding to oldDataTarget
    }
    action {
        update pairEnumConstant {
        		val arrayArguments = (pairEnumConstant.arguments.get(PAIR_ARGUMENT_DATA_SETS) as ArrayInstantiationByValuesTyped).arrayInitializer.initialValues
				val position = arrayArguments.removeFirst(e|(Confidentiality2AnnotationsUtil.toString(e as Expression)).equals(Confidentiality2AnnotationsUtil.toString(dataSetEnumConstant)))
        		val enumConstantName = Confidentiality2AnnotationsUtil.createEnumConstantName((newDataTarget as DataSet).name)
				val newDataSetExpression = Confidentiality2AnnotationsContentCreationUtil.createEnumerationReferenceDotEnumConstant(DATA_SETS_ENUMERATION, enumConstantName)
				arrayArguments.add(position, newDataSetExpression)
        }
    }
}

// ################ PARAMETER SOURCES ################

reaction CreatedParametersAndDataPairParameterSource {
	after attribute insert in conf::ParametersAndDataPair[parameterSources]
	call createParametersAndDataPairParameterSource(affectedEObject, newValue, index)
}

reaction DeletedParametersAndDataPairParameterSource {
	after attribute remove from conf::ParametersAndDataPair[parameterSources]
	call deleteParametersAndDataPairParameterSource(affectedEObject, oldValue, index)
}

reaction ReplacedParametersAndDataPairParameterSource {
	after attribute replaced at conf::ParametersAndDataPair[parameterSources]
	call {
		replaceParametersAndDataPairParameterSource(affectedEObject, newValue, oldValue)
	}
}

routine createParametersAndDataPairParameterSource(conf::ParametersAndDataPair parametersAndDataPair, String parameterSource, Integer position) {
    match {
        val enumConstant = retrieve java::EnumConstant corresponding to parametersAndDataPair
    }
    action {
        val stringLiteral = create java::StringReference and initialize {
    			stringLiteral.value = Optional.ofNullable(parameterSource).orElse("");
        }
        update enumConstant {
				var stringArrayArgument = enumConstant.arguments.get(Confidentiality2AnnotationsUtil.PAIR_ARGUMENT_PARAMETER_SOURCES) as ArrayInstantiationByValuesTyped
				stringArrayArgument.arrayInitializer.initialValues.add(position, stringLiteral)
        }
    }
}

routine deleteParametersAndDataPairParameterSource(conf::ParametersAndDataPair parametersAndDataPair, String oldParameterSource, Integer position) {
    match {
        val enumConstant = retrieve java::EnumConstant corresponding to parametersAndDataPair
    }
    action {
        update enumConstant {
				var stringArrayArgument = enumConstant.arguments.get(Confidentiality2AnnotationsUtil.PAIR_ARGUMENT_PARAMETER_SOURCES) as ArrayInstantiationByValuesTyped
				stringArrayArgument.arrayInitializer.initialValues.remove(position as int)
        }
    }
}

routine replaceParametersAndDataPairParameterSource(conf::ParametersAndDataPair parametersAndDataPair, String newParameterSource, String oldParameterSource) {
    match {
        val enumConstant = retrieve java::EnumConstant corresponding to parametersAndDataPair
    }
    action {
        val stringLiteral = create java::StringReference and initialize {
    			stringLiteral.value = Optional.ofNullable(newParameterSource).orElse("");
        }
        update enumConstant {
				var stringArrayArgument = enumConstant.arguments.get(Confidentiality2AnnotationsUtil.PAIR_ARGUMENT_PARAMETER_SOURCES) as ArrayInstantiationByValuesTyped
				val parameterSources = stringArrayArgument.arrayInitializer.initialValues
				val position = parameterSources.removeFirst(e|(e as StringReference).value.equals(oldParameterSource))
				parameterSources.add(position as int, stringLiteral)
        }
    }
}


// ###################################################
// ###### CONFIDENTIALITY REPOSITORY REACTIONS #######

reaction CreatedConfidentialitySpecification {
	after element conf::ConfidentialitySpecification created and inserted as root
	call {
		createJavaPackage(newValue, null, "confidentialityRepository", "specification");
		// Also create and add correspondences to java classes contained in package
		createConfidentialitySpecificationClasses(newValue);
	}
}

routine createConfidentialitySpecificationClasses(conf::ConfidentialitySpecification specification)	 { 
	match {
		val confSpecificationPackage = retrieve java::Package corresponding to specification
	} 
	action { 
		call {
			createJavaAnnotation(specification, confSpecificationPackage, "InformationFlow", "InformationFlow");
			// TODO not working because of correspondence bug:
			// setInformationFlowAnnotationContent(specification);
			createJavaEnum(specification, confSpecificationPackage, "DataSets", "DataSets");
			setDataSetsEnumerationContent(specification);
			createJavaEnum(specification, confSpecificationPackage, "ParametersAndDataPairs", "ParametersAndDataPairs");
			setParametersAndDataPairsEnumerationContent(specification);
			// TODO only creation not yet content
			createJavaEnum(specification, confSpecificationPackage, "DataSetMapEntries", "DataSetMapEntries");
			createJavaEnum(specification, confSpecificationPackage, "DataSetMaps", "DataSetMaps");
			createJavaEnum(specification, confSpecificationPackage, "SpecificationParameters", "SpecificationParameters");
			createJavaEnum(specification, confSpecificationPackage, "ParameterizedDataSetMapEntries", "ParameterizedDataSetMapEntries");
		}
	}
}

// source: tools.vitruv.applications.pcmjava.pojotransformations.pcm2java
routine createJavaPackage(EObject sourceElementMappedToPackage, java::Package parentPackage, String packageName, String newTag)	 { 
	match {
		require absence of java::Package corresponding to sourceElementMappedToPackage tagged with newTag
	} 
	action { 
		val javaPackage = create java::Package and initialize {
			if (parentPackage !== null) {
				javaPackage.namespaces += parentPackage.namespaces;
				javaPackage.namespaces += parentPackage.name; 
			}
			javaPackage.name = packageName;
			persistProjectRelative(sourceElementMappedToPackage, javaPackage, Confidentiality2AnnotationsUtil.buildJavaFilePath(javaPackage));
		}
		add correspondence between javaPackage and sourceElementMappedToPackage tagged with newTag
	}
}

// modified from: tools.vitruv.applications.pcmjava.pojotransformations.pcm2java
routine createJavaAnnotation(conf::ConfidentialitySpecification specification, java::Package containingPackage, String className, String newTag) {
	action { 
		val javaAnnotation = create java::Annotation and initialize {
			javaAnnotation.name = className;
			javaAnnotation.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		}
		add correspondence between javaAnnotation and specification tagged with newTag
		call createCompilationUnit(specification, javaAnnotation, containingPackage, newTag)
		// TODO workaround for the correspondence bug (possible since there is only a single annotation)
		execute {
			Confidentiality2AnnotationsContentCreationUtil.setInformationFlowAnnotation(javaAnnotation);
		}
	}
}

// modified from: tools.vitruv.applications.pcmjava.pojotransformations.pcm2java
routine createJavaEnum(conf::ConfidentialitySpecification specification, java::Package containingPackage, String className, String newTag) {
	action { 
		val javaEnumeration = create java::Enumeration and initialize {
			javaEnumeration.name = className;
			javaEnumeration.addModifier(ModifiersFactory.eINSTANCE.createPublic());
		}
		add correspondence between javaEnumeration and specification tagged with newTag
		call createCompilationUnit(specification, javaEnumeration, containingPackage, newTag)
	}
}

// modified from: tools.vitruv.applications.pcmjava.pojotransformations.pcm2java
routine createCompilationUnit(conf::ConfidentialitySpecification specification, java::ConcreteClassifier classifier, java::Package containingPackage, String newTag) {
	action {
		val compilationUnit = create java::CompilationUnit and initialize {
			compilationUnit.namespaces += containingPackage.namespaces;
			compilationUnit.namespaces += containingPackage.name;
			compilationUnit.name = classifier.name + ".java";
			compilationUnit.classifiers.add(classifier);
			persistProjectRelative(specification, compilationUnit, Confidentiality2AnnotationsUtil.buildJavaFilePath(compilationUnit));
		}
		add correspondence between compilationUnit and specification tagged with newTag
	}
}

// TODO not working because of correspondence bug
//routine setInformationFlowAnnotationContent(conf::ConfidentialitySpecification specification)	 { 
//	match {
//		val informationFlowAnnotation = retrieve java::Annotation corresponding to specification tagged with "InformationFlow"
//	} 
//	action { 
//		call {
//			Confidentiality2AnnotationsContentCreationUtil.setInformationFlowAnnotation(informationFlowAnnotation);
//		}
//	}
//}

routine setDataSetsEnumerationContent(conf::ConfidentialitySpecification specification)	 { 
	match {
		val dataSetsEnumeration = retrieve java::Enumeration corresponding to specification tagged with "DataSets"
	} 
	action { 
		call {
			Confidentiality2AnnotationsContentCreationUtil.setDataSetEnumeration(dataSetsEnumeration);
		}
	}
}

routine setParametersAndDataPairsEnumerationContent(conf::ConfidentialitySpecification specification)	 { 
	match {
		val parametersAndDataPairsEnumeration = retrieve java::Enumeration corresponding to specification tagged with "ParametersAndDataPairs"
	} 
	action { 
		call {
			Confidentiality2AnnotationsContentCreationUtil.setParametersAndDataPairEnumeration(parametersAndDataPairsEnumeration);
		}
	}
}